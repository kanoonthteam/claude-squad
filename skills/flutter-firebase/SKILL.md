---
name: flutter-firebase
description: Flutter skill â€” Firebase Core setup, FCM push notifications, local notifications, analytics tracking, and deep linking from notifications
---

# Flutter Firebase Integration

Firebase integration patterns for the ironmove-app. Covers Firebase Core initialization before runApp, Firebase Cloud Messaging (FCM) with a singleton PushNotificationService, local notifications for foreground display, stream controllers for notification taps and foreground messages, FCM token registration during OTP verification, and Firebase Analytics with release-only tracking across 54 events.

## Table of Contents

1. [Firebase Core Setup](#firebase-core-setup)
2. [FCM - PushNotificationService](#fcm---pushnotificationservice)
3. [Local Notifications](#local-notifications)
4. [Notification Flow - Stream Controllers](#notification-flow---stream-controllers)
5. [FCM Token Registration](#fcm-token-registration)
6. [Firebase Analytics](#firebase-analytics)
7. [Best Practices](#best-practices)
8. [Anti-Patterns](#anti-patterns)

---

## Firebase Core Setup

Firebase is initialized in `main.dart` before `runApp`. The background message handler is registered as a top-level function immediately after initialization. Analytics is initialized as part of the startup sequence.

```dart
// lib/main.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ironmove_app/firebase_options.dart';
import 'package:ironmove_app/services/push_notification_service.dart';
import 'package:ironmove_app/services/analytics_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 1. Initialize Firebase (with duplicate protection)
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
  } catch (e) {
    debugPrint('Firebase already initialized: $e');
  }

  // 2. Register background message handler (top-level function)
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  // 3. Initialize Firebase Analytics
  await AnalyticsService.instance.initialize();

  // 4. Initialize environment variables
  await Env.init();

  // 5. Run app inside ProviderScope
  runApp(
    const ProviderScope(
      child: IronmoveApp(),
    ),
  );
}
```

The `firebase_options.dart` is generated by FlutterFire CLI and provides `DefaultFirebaseOptions.currentPlatform` for platform-specific configuration.

---

## FCM - PushNotificationService

The `PushNotificationService` is a singleton that owns the `FirebaseMessaging` instance, the `FlutterLocalNotificationsPlugin`, and two broadcast `StreamController`s. It handles all three app states: foreground, background, and terminated.

```dart
// lib/services/push_notification_service.dart
class PushNotificationService {
  static PushNotificationService? _instance;
  static PushNotificationService get instance => _instance ??= PushNotificationService._();

  PushNotificationService._();

  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;
  final FlutterLocalNotificationsPlugin _localNotifications = FlutterLocalNotificationsPlugin();

  // Stream controllers for notification events
  final StreamController<Map<String, dynamic>> _notificationTapController =
      StreamController<Map<String, dynamic>>.broadcast();
  final StreamController<RemoteMessage> _foregroundNotificationController =
      StreamController<RemoteMessage>.broadcast();

  // Authentication check callback
  bool Function()? _isAuthenticatedCallback;

  Stream<Map<String, dynamic>> get onNotificationTap => _notificationTapController.stream;
  Stream<RemoteMessage> get onForegroundNotification => _foregroundNotificationController.stream;

  void setAuthenticationCallback(bool Function() isAuthenticated) {
    _isAuthenticatedCallback = isAuthenticated;
  }

  Future<Result<void>> initialize() async {
    try {
      // Initialize local notifications
      await _initializeLocalNotifications();

      // Request notification permissions
      final NotificationSettings settings = await _firebaseMessaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        carPlay: false,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );

      if (settings.authorizationStatus == AuthorizationStatus.denied) {
        return Failure(
          'Notification permission denied',
          exception: AppException('Notification permission denied'),
        );
      }

      // Configure message handlers for all app states
      _configureMessageHandlers();

      return const Success(null);
    } catch (e) {
      return Failure(
        'Failed to initialize push notifications',
        exception: AppException('Failed to initialize push notifications', originalError: e),
      );
    }
  }

  void dispose() {
    _notificationTapController.close();
    _foregroundNotificationController.close();
  }
}
```

### Background Message Handler

The background handler is a top-level function annotated with `@pragma('vm:entry-point')`. It must re-initialize Firebase because it runs in a separate isolate.

```dart
// lib/services/push_notification_service.dart (top-level)
@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();

  debugPrint('PushNotificationService: Background message received');
  debugPrint('PushNotificationService: Title: ${message.notification?.title}');
  debugPrint('PushNotificationService: Data: ${message.data}');
}
```

---

## Local Notifications

Local notifications are initialized inside `PushNotificationService._initializeLocalNotifications()`. When a notification is tapped, the payload is emitted to the `_notificationTapController` stream.

```dart
// lib/services/push_notification_service.dart
Future<void> _initializeLocalNotifications() async {
  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher');

  const DarwinInitializationSettings initializationSettingsIOS =
      DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );

  const InitializationSettings initializationSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initializationSettingsIOS,
  );

  await _localNotifications.initialize(
    initializationSettings,
    onDidReceiveNotificationResponse: (NotificationResponse details) {
      if (details.payload != null) {
        final Map<String, dynamic> data = {'payload': details.payload};
        _notificationTapController.add(data);
      }
    },
  );
}
```

### Fallback Local Notification Display

When the foreground toast fails, a fallback local notification is shown with Android channel configuration:

```dart
// lib/services/push_notification_service.dart
Future<void> _showFallbackLocalNotification(RemoteMessage message) async {
  const AndroidNotificationDetails androidNotificationDetails =
      AndroidNotificationDetails(
        'ironmove_notifications',
        'Ironmove Notifications',
        channelDescription: 'Notifications for task assignments and updates',
        importance: Importance.high,
        priority: Priority.high,
        showWhen: true,
      );

  const DarwinNotificationDetails iosNotificationDetails =
      DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
      );

  const NotificationDetails notificationDetails = NotificationDetails(
    android: androidNotificationDetails,
    iOS: iosNotificationDetails,
  );

  await _localNotifications.show(
    message.hashCode,
    message.notification?.title ?? 'Ironmove',
    message.notification?.body ?? 'New notification',
    notificationDetails,
    payload: jsonEncode(message.data),
  );
}
```

---

## Notification Flow - Stream Controllers

The service uses two broadcast `StreamController`s to decouple notification handling from the UI:

- `_notificationTapController` -- emits `Map<String, dynamic>` when user taps a notification (from background, terminated, or local notification)
- `_foregroundNotificationController` -- emits `RemoteMessage` when a push arrives while the app is in the foreground

### Configuring Handlers for All Three App States

```dart
// lib/services/push_notification_service.dart
void _configureMessageHandlers() {
  // 1. Foreground: show as toast, emit to stream
  FirebaseMessaging.onMessage.listen((RemoteMessage message) {
    _showForegroundNotification(message);
  });

  // 2. Background: user tapped notification, emit data for navigation
  FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
    _notificationTapController.add(message.data);
  });

  // 3. Terminated: app launched from notification tap
  FirebaseMessaging.instance.getInitialMessage().then((RemoteMessage? message) {
    if (message != null) {
      _notificationTapController.add(message.data);
    }
  });
}
```

### Foreground Notification with Authentication Check

Before showing a foreground notification, the service checks if the user is authenticated using the callback set from main.dart:

```dart
// lib/services/push_notification_service.dart
Future<void> _showForegroundNotification(RemoteMessage message) async {
  try {
    // Skip if user is not authenticated
    if (_isAuthenticatedCallback != null && !_isAuthenticatedCallback!()) {
      return;
    }

    // Emit to stream for the app to handle with proper context
    _foregroundNotificationController.add(message);
  } catch (e) {
    // Fallback to local notification on error
    await _showFallbackLocalNotification(message);
  }
}
```

### Authentication Callback Integration in main.dart

The authentication callback is wired up after PushNotificationService is initialized:

```dart
// lib/main.dart - IronmoveApp initState
Future<void> _initializeNotificationService() async {
  await PushNotificationService.instance.initialize();

  // Set authentication callback for notification filtering
  PushNotificationService.instance.setAuthenticationCallback(() {
    final authState = ref.read(authProvider);
    return authState.isAuthenticated;
  });
}

void _setupNotificationHandling() {
  // Listen to push notification taps for navigation
  PushNotificationService.instance.onNotificationTap.listen((data) {
    _handleNotificationTap(data);
  });
}
```

### Foreground Toast via NotificationWrapper

A `NotificationWrapper` widget listens to the foreground notification stream and displays an overlay toast with tap-to-navigate:

```dart
// lib/main.dart
class _NotificationWrapperState extends ConsumerState<NotificationWrapper> {
  StreamSubscription<RemoteMessage>? _subscription;

  @override
  void initState() {
    super.initState();
    _subscription = PushNotificationService.instance.onForegroundNotification.listen((message) {
      final title = message.notification?.title ?? 'Ironmove';
      final body = message.notification?.body ?? 'New notification';
      NotificationToastHelper.showNotificationToast(title, body, data: message.data);
    });
  }

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}
```

### Navigation from Notification Tap

Notification taps are routed through `_handleNotificationTap` which parses `task_id` from the data and navigates via GoRouter:

```dart
// lib/main.dart
void _performNavigation(Map<String, dynamic> notificationData) {
  final router = ref.read(routerProvider);

  if (notificationData.containsKey('task_id')) {
    final taskId = notificationData['task_id'].toString();
    router.pushNamed('task-details', pathParameters: {'id': taskId});
  } else if (notificationData.containsKey('type')) {
    final type = notificationData['type'].toString();
    if (type == 'task_assignment') {
      final taskId = notificationData['task_id']?.toString() ?? notificationData['id']?.toString();
      if (taskId != null) {
        router.pushNamed('task-details', pathParameters: {'id': taskId});
      } else {
        router.pushNamed('tasks');
      }
    } else {
      router.pushNamed('tasks');
    }
  } else {
    router.pushNamed('tasks');
  }
}
```

---

## FCM Token Registration

The FCM token is obtained during OTP verification and sent to the backend as part of the `verifyAuthCode` call. Token refresh is subscribed separately.

```dart
// lib/providers/auth_provider.dart - verifyOtp method
Future<void> verifyOtp(String code) async {
  state = state.copyWith(isLoading: true, error: null);

  try {
    // Get FCM token before verifying OTP
    String? fcmToken;
    try {
      final pushService = PushNotificationService.instance;
      await pushService.initialize();
      final tokenResult = await pushService.getFCMToken();
      if (tokenResult.isSuccess) {
        fcmToken = tokenResult.dataOrNull;
      }
    } catch (e) {
      debugPrint('Auth: Failed to get FCM token: $e');
    }

    // Pass FCM token to backend during OTP verification
    final response = await _apiService.verifyAuthCode(
      state.phoneNumber!,
      code,
      fcmToken: fcmToken,
    );

    final accessToken = response['access_token'] as String?;
    // ... save token and update state
  } catch (e) {
    // ... handle error
  }
}
```

### Token Retrieval and Refresh

```dart
// lib/services/push_notification_service.dart
Future<Result<String?>> getFCMToken() async {
  try {
    final token = await _firebaseMessaging.getToken();
    return Success(token);
  } catch (e) {
    return Failure(
      'Failed to get FCM token',
      exception: AppException('Failed to get FCM token', originalError: e),
    );
  }
}

void subscribeToTokenRefresh(Function(String) onTokenRefresh) {
  _firebaseMessaging.onTokenRefresh.listen((newToken) {
    onTokenRefresh(newToken);
  });
}
```

---

## Firebase Analytics

The `AnalyticsService` is a singleton that wraps `FirebaseAnalytics`. It only fires events in release mode (`kReleaseMode`) to avoid polluting development data. The service provides a `FirebaseAnalyticsObserver` for automatic screen tracking via GoRouter.

### Singleton Setup with Release-Only Guard

```dart
// lib/services/analytics_service.dart
class AnalyticsService {
  static AnalyticsService? _instance;
  static AnalyticsService get instance => _instance ??= AnalyticsService._();

  AnalyticsService._();

  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  // Only active in release builds
  bool get _isEnabled => kReleaseMode;

  // Observer for GoRouter automatic screen tracking
  FirebaseAnalyticsObserver get observer =>
      FirebaseAnalyticsObserver(analytics: _analytics);

  Future<void> initialize() async {
    if (!_isEnabled) {
      debugPrint('AnalyticsService: Disabled in debug mode');
      return;
    }
    await _analytics.setAnalyticsCollectionEnabled(true);
    await logEvent('app_opened');
  }
}
```

### Core Logging Methods

All event methods follow the same pattern: check `_isEnabled`, call `_analytics`, wrap in try/catch:

```dart
// lib/services/analytics_service.dart
Future<void> logEvent(
  String name, {
  Map<String, dynamic>? parameters,
}) async {
  if (!_isEnabled) return;

  try {
    final Map<String, Object>? analyticsParams = parameters?.map(
      (key, value) => MapEntry(key, value as Object),
    );
    await _analytics.logEvent(name: name, parameters: analyticsParams);
  } catch (e) {
    debugPrint('AnalyticsService: Error logging event: $e');
  }
}

Future<void> logScreenView({
  required String screenName,
  String? screenClass,
}) async {
  if (!_isEnabled) return;
  await _analytics.logScreenView(
    screenName: screenName,
    screenClass: screenClass ?? screenName,
  );
}

Future<void> setUserId(String? userId) async {
  if (!_isEnabled) return;
  await _analytics.setUserId(id: userId);
}

Future<void> setUserProperty({
  required String name,
  required String? value,
}) async {
  if (!_isEnabled) return;
  await _analytics.setUserProperty(name: name, value: value);
}
```

### Event Categories

The 54 analytics events are organized into these categories:

**Auth events** (4): `app_opened`, `otp_verification_attempt`, `otp_verification_failed`, `logout`

```dart
Future<void> logLogin({required String method}) async {
  if (!_isEnabled) return;
  await _analytics.logLogin(loginMethod: method);
}
```

**Task events** (4): `task_viewed`, `task_status_updated`, `task_started`, `task_completed`

```dart
Future<void> logTaskStatusUpdate({
  required String taskId,
  required String oldStatus,
  required String newStatus,
}) async {
  await logEvent('task_status_updated', parameters: {
    'task_id': taskId,
    'old_status': oldStatus,
    'new_status': newStatus,
  });
}
```

**Expense events** (3): `expense_created`, `expense_updated`, `expense_deleted`

```dart
Future<void> logExpenseCreated({
  required String taskId,
  required String expenseType,
  required double amount,
}) async {
  await logEvent('expense_created', parameters: {
    'task_id': taskId,
    'expense_type': expenseType,
    'amount': amount,
  });
}
```

**Location events** (2): `location_tracking_started`, `location_tracking_stopped`

**Cache events** (4): `directions_cache_hit`, `directions_cache_miss`, `directions_api_call`, `directions_cache_cleared`

**Navigation events** (1): `navigation_tap`

**Error events** (1): `app_error`

**No sensitive data** -- phone numbers are truncated before logging (e.g., `phone.substring(0, 6) + '****'`), and user IDs use internal identifiers rather than PII.

```dart
// From OTP screen - partial phone for privacy
await AnalyticsService.instance.logEvent('otp_verification_attempt', parameters: {
  'phone_number': '${widget.phoneNumber.substring(0, 6)}****',
});
```

---

## Best Practices

1. **Initialize Firebase before runApp** -- `Firebase.initializeApp()` must complete before any Firebase service is accessed. Wrap in try/catch to handle duplicate initialization gracefully.

2. **Register background handler as a top-level function** -- `FirebaseMessaging.onBackgroundMessage` requires a top-level or static function annotated with `@pragma('vm:entry-point')`. It runs in a separate isolate and cannot access providers or widget state.

3. **Handle all three app states** -- Foreground (`onMessage`), background (`onMessageOpenedApp`), and terminated (`getInitialMessage`). Missing any one of these leads to lost notifications or broken navigation.

4. **Use broadcast StreamControllers to decouple** -- The PushNotificationService emits events via streams, and the UI subscribes. This avoids tight coupling between notification handling and widget tree context.

5. **Check authentication before showing foreground notifications** -- Use a callback to check `authState.isAuthenticated` so notifications are not displayed on the login screen.

6. **Send FCM token during authentication** -- Register the token with the backend during OTP verification so the server can immediately target the device.

7. **Guard analytics with kReleaseMode** -- Only track events in release builds to keep development and staging data clean.

8. **Never log sensitive data in analytics** -- Truncate phone numbers, avoid logging passwords or tokens, use internal IDs for user identification.

---

## Anti-Patterns

- **Accessing FirebaseMessaging.instance before Firebase.initializeApp** -- Always await initialization first. Accessing instances before initialization throws a `FirebaseException`.

- **Putting business logic in the background message handler** -- The background isolate has no access to providers, widget tree, or DI container. Keep it minimal. Process data when the app resumes.

- **Not handling getInitialMessage on startup** -- If the app was terminated and the user taps a notification, `onMessageOpenedApp` does NOT fire. You must call `getInitialMessage()` once during initialization.

- **Closing non-broadcast StreamControllers with multiple listeners** -- Use `StreamController.broadcast()` for notification streams since multiple widgets may listen simultaneously.

- **Logging analytics events in debug builds** -- This pollutes production analytics dashboards. Always gate behind `kReleaseMode`.

- **Logging high-cardinality parameters** -- Firebase Analytics limits you to 500 distinct event types and 25 user properties. Use fixed event names with parameters instead of dynamic event names.

- **Not cancelling stream subscriptions** -- Foreground and background message listeners return `StreamSubscription` objects. Cancel them in `dispose()` to prevent duplicate handlers and memory leaks.

- **Showing foreground notifications without authentication check** -- Notifications arriving before login or on the login screen should be silently ignored.
